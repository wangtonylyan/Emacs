#+TITLE: Main
* Network

** terminology

*** address

+ address realm :: a network domain in which the network addresses are uniquely assigned to entities such that datagrams can be routed to them.

**** categorized by layer

+ IP address :: an IP-layer identifier for an interface or a set of interfaces.

+ link-layer address :: a link-layer identifier for an interface.

 Examples include IEEE 802 addresses for Ethernet links (e.g. EHA) and E.164 addresses for Integrated Services Digital Network (ISDN) links.

 Typically, the link-layer address is an interface’s Media Access Control (MAC) address.

**** categorized by realm

+ link-local address :: an address having link-only scope that can be used to reach neighboring nodes attached to the same link.

 All interfaces have a link-local unicast address.

+ global address :: an address with unlimited scope.

+ unicast address :: an identifier for a single interface.

 A packet sent to a unicast address is delivered to the interface identified by that address.

+ multicast address :: an identifier for a set of interfaces (typically belonging to different nodes).

 A packet sent to a multicast address is delivered to all interfaces identified by that address.

+ anycast address :: an identifier for a set of interfaces (typically belonging to different nodes).

 A packet sent to an anycast address is delivered to one of the interfaces identified by that address (the "nearest" one, according to the routing protocol’s measure of distance).

**** categorized by state

+ tentative address :: an address whose uniqueness on a link is being verified, prior to its assignment to an interface.

 A tentative address is not considered assigned to an interface in the usual sense.
 An interface discards received packets addressed to a tentative address, but accepts Neighbor Discovery packets related to Duplicate Address Detection for the tentative address.

+ preferred address :: an address assigned to an interface whose use by upper-layer protocols is unrestricted.

 Preferred addresses may be used as the source (or destination) address of packets sent from (or to) the interface.

  + preferred lifetime :: the length of time that a valid address is preferred (i.e. the time until deprecation)

   When the preferred lifetime expires, the address becomes deprecated.

+ deprecated address :: an address assigned to an interface whose use is discouraged, but not forbidden.

 A deprecated address should no longer be used as a source address in new communications, but packets sent from or to deprecated addresses are delivered as expected.
 A deprecated address may continue to be used as a source address in communications where switching to a preferred address causes hardship to a specific upper-layer activity (e.g., an existing TCP connection).

+ valid address :: a preferred or deprecated address.

 A valid address may appear as the source or destination address of a packet, and the Internet routing system is expected to deliver packets sent to a valid address to their intended recipients.

  + valid lifetime :: the length of time an address remains in the valid state (i.e. the time until invalidation)

   The valid lifetime must be greater than or equal to the preferred lifetime.
   When the valid lifetime expires, the address becomes invalid.

+ invalid address :: an address that is not assigned to any interface.

 A valid address becomes invalid when its valid lifetime expires.

 Invalid addresses should not appear as the destination or source address of a packet.
 In the former case, the Internet routing system will be unable to deliver the packet; in the latter case, the recipient of the packet will be unable to respond to it.

*** device

+ node :: a device that implements IPv6.

+ router :: a node that forwards IPv6 packets not explicitly addressed to itself.

+ host :: any node that is not a router.

+ end ::

+ neighbor :: nodes attached to the same link.

+ interface :: a node’s attachment to a link.

+ link MTU :: the maximum transmission unit, i.e., maximum packet size in octets, that can be conveyed over a link.

+ path MTU :: the minimum link MTU of all the links in a path between a source node and a destination node.

+ session :: a set of traffic that is managed as a unit.

+ session/connection flow :: 由多个packet flow组成，由谁首先发起连接请求，来决定flow的方向

+ packet flow :: 其方向为单个packet的传输方向

**** link layer

+ link :: A facility or medium over which nodes can communicate at the link layer.

+ switch ::

+ hub ::

+ repeater ::

+ bridge :: A node connected to two or more administratively indistinguishable but physically distinct subnets, that automatically forwards datagrams when necessary, but whose existence is not known to other hosts.

 Also called a "software repeater".

**** network layer

+ gateway :: A node connected to two or more administratively distinct networks and/or subnets, to which hosts send datagrams to be forwarded.

  1. A gateway implements internet protocol to forward datagrams between networks.

  2. A gateway also implements the Gateway to Gateway Protocol (GGP) to coordinate routing and other internet control information.

+ router ::

** Computer Networking: A Top-Down Approach

*** Chapter 4. The Network Layer
**** routing protocol
+ Internet’s intra-autonomous system routing protocols :: RIP, OSPF, and IS-IS
+ Internet's inter-autonomous system routing protocol :: BGP
**** packet
|-----------+----------|
| layer     | packet   |
|-----------+----------|
| transport | segment  |
| network   | datagram |
| link      | frame    |
**** forwarding =vs.= routing
Forwarding refers to the router-local action of transferring a packet from an input link interface to the appropriate output link interface.
Routing refers to the network-wide process that determines the end-to-end paths that packets take from source to destination.
**** forwarding table
路由器内部会维护一张forwarding table，从而实现forwarding功能
**** network service model
***** Internet
best-effort service
***** ATM
provides multiple service models
+ constant bit rate (CBR) :: a dedicated fixed-bandwidth transmission link
+ available bit rate (ABR) :: slightly-better-than-best-effort service
**** network-layer connection and connectionless service
Although the connection and connectionless services at network layer have some parallels with those at transport layer, there are differences as follows,
|--------------------------------------------------------+--------------------------------------------------------------------|
| transport layer                                        | network layer                                                      |
|--------------------------------------------------------+--------------------------------------------------------------------|
| process-to-process                                     | host-to-host                                                       |
| can provice both connection and connectionless service | virtual-circuit xor datagram                                       |
| Connection service is implemented in end systems only. | Connection service is implemented in both routers and end systems. |
**** virtual-circuit network
1. A computer network that provides only a connection or connectionless service at the network layer is called a *virtual-circuit* network or *datagram* network, respectively.
2. The network-layer connection is called *virtual circuit* (VC).
3. The network's routers must maintain *connection state information* for the ongoing connections.
 对于VC而言，其连接的建立涉及到了整条路径上的每一台设备，所有中间路由都需要为每个连接维护单独的信息。


* Docker
** references
[[http://goinbigdata.com/docker-run-vs-cmd-vs-entrypoint/][RUN vs. CMD vs. ENTRYPOINT]]

** concept
1. An *image* is an executable package that includes everything needed to run an application, including the code, a runtime, libraries, environment variables, and configuration files.
2. A *container* is a runtime instance of an image, i.e. what the image becomes in memory when executed.
 *Dockerfile*与container一一绑定
3. docker engine = docker + dockerd
 服务器端是一个名为dockerd的daemon进程，客户端则是每次执行docker命令时所起的进程，两者之间通过REST API进行通信。
 由于镜像、容器等的维护都被执行于该daemon中，因此客户端也可以通过网络，远程控制另一台主机中的docker engine。
 目前dockerd还提供了分布式模型，多个daemon可以组成集群，用户可对负载、资源占用等进行配置。
4. 构建镜像时需要指定目录，该被指定目录被称为是context，即被Docker认为是对于本次构建有用的信息，
 因而该目录下的所有文件都会在Docker客户端执行"docker build"命令时，被完整地传给dockerd进程。
   + 可见，出于执行效率的考虑，每次构建镜像时，通常都需要新建一个空目录，仅将对本次构建真正有必要的文件置于其中；
     此外，也可以在被指定的目录下新建.dockerignore文件，用于指定需要被忽略的内容。
5. Dockerfile的语法规则可参见[[https://docs.docker.com/engine/reference/builder/][此网页]]
6. layer
 In an image, a layer is modification to the image, represented by an instruction in the Dockerfile.
 Layers are applied in sequence to the base image to create the final image.
** configuration
*** config file
1. /etc/default/docker，该文件不支持systemctl所管理的dockerd进程
2. /etc/docker/daemon.json

** install
1. Docker的安装可直接参考[[https://docs.docker.com/install/linux/docker-ce/ubuntu/][官方文档]]
2. 增加非root权限
 #+begin_src sh
sudo groupadd docker
sudo usermod -aG docker $USER
 #+end_src
3. 开机启动
 #+begin_src sh
sudo systemctl enable docker
 #+end_src
** command
*** CLI commands
#+begin_src sh
docker
docker container --help
#+end_src
*** info
#+begin_src sh
docker --version
docker version
docker info
#+end_src
*** hub
#+begin_src sh
docker login                                      # Log in this CLI session using your Docker credentials
docker tag <image> <username>/<repository>:<tag>  # Tag image for upload to registry
docker push <username>/<repository>:<tag>         # Upload tagged image to registry
docker pull <username>/<repository>:<tag>
docker search <image>
#+end_src
*** image
1. 在DockerHub中，一个镜像的完整标示符的格式是"<username>/<repository>:<tag>"，其中
   + 没有username的镜像属于顶级命名空间，仅用于官方镜像

#+begin_src sh
docker image ls
docker image ls -a                        # List all images on this machine
docker image rm <image>                   # Remove specified image from this machine
docker image rm $(docker image ls -a -q)  # Remove all images from this machine
docker build -t <image> .                 # Create image using the Dockerfile in current directory
#+end_src
*** container
#+begin_src sh
docker ps  # docker container ls
docker ps -a  # docker container ls -a

docker stop <hash>  # docker container stop <hash>
docker kill <hash>  # docker container kill <hash>

docker rm <hash>  # docker container rm <hash>
docker rm $(docker ps -a -q -f status=exited)  # Remove all exited containers
#+end_src
*** run -- the most mighty command
#+begin_src sh
docker run <image>
docker run -p 4000:80 <image>             # Run image mapping port 4000 to 80，两者分别是主机和容器内的端口号
docker run -d -p 4000:80 <image>          # Same thing, but in detached mode
docker run <username>/<repository>:<tag>  # Run image from a registry
docker run -it <image>                    # attach to an interactive tty in container
#+end_src


*** example
#+begin_src sh
docker pull busybox
docker image ls
docker run busybox
docker container ls -a
docker run -it busybox sh
#+end_src

* shell
** color
#+begin_src sh
tput color
#+end_src

* tmux
** commands
*** session
#+begin_src sh
tmux new -s <session>  # tmux new-session -s <session>
tmux ls  # tmux list-sessions
tmux attach -t <session> # tmux attach-session -t <session>
tmux kill-session -t <session>
#+end_src
*** configuration in tmux.conf file
#+begin_src sh
set-option  # set
set-window-option  # setw
#+end_src
*** tmux command
#+begin_src sh
source-file ~/.tmux.conf
#+end_src

** key bindings
+ t :: clock
+ d :: detach current session
+ , :: (re)name window
+ [0-9] :: jump to window, "C-x b"
+ w :: visual menu of windows
+ f :: find a window
+ & :: kill a window
+ % :: "C-x 3"
+ " :: "C-x 2"
+ o :: "C-x o"
+ x :: close a pane
+ : :: command mode
+ ? :: key bindings



* Git
** Magit
*** merge
合并时若存在冲突，在存在冲突的文件名所在行，执行"Ediff (dwim)"命令即可使用Ediff工具对冲突的内容进行比较呈现。
此时通常会呈现出三个不同子窗口，编号为"a"和"b"的两个窗口是两个不同版本的内容，编号为"c"的窗口则是合并执行后的结果。
处理完成后，执行"q"退出ediff会话时，会提示是否保存合并后的结果。

** config
*** basic
**** local *vs.* global
前者作为缺省值；这两个参数可以与以下各子命令结合使用
#+begin_src sh
git config --local   # "./.git/config"
git config --global  # "~/.gitconfig"
#+end_src
**** list
#+begin_src sh
git config --list
#+end_src
**** unset
#+begin_src sh
git config --unset
#+end_src
*** account
**** user info
#+begin_src sh
git config user.name "TonyLYan"
git config user.email "wangtonylyan@outlook.com"
#+end_src
**** credential
设置以下选项后的首次git push时所输入的用户名和Token密码，将被自动地以明文的方式，保存于~/.git-credentials文件中
当启用Github账号登陆二次验证机制时，通过命令行执行push等操作时，要求输入的账号密码必须是由官网上手动生成的Personal Access Token，而非账号的登陆密码。此时，将密码自动保存于本地就是一个很好的举措
#+begin_src sh
git config credential.helper store
#+end_src
*** network
**** proxy
#+begin_src sh
git config http.proxy "http://<username>:<password>@<server>:<port>"
git config https.proxy "https://<username>:<password>@<server>:<port>"
#+end_src
**** ssl
#+begin_src sh
git config http.sslverify false  # 用于解决server certificate verification failed错误
#+end_src
*** alias
#+begin_src sh
git config alias.st status
git config alias.br branch
git config alias.co checkout
git config alias.cm commit
git config alias.rs reset
#+end_src
*** core
**** newline
#+begin_src sh
git config core.autocrlf input  # 用于转换\r\n与\n，在Linux和Windows上的值分别应为input和true
#+end_src
** submodule
*** initialize
+ 在首先克隆一个仓库后，只会存在有子模块的文件夹，而不会下载其代码
+ 子模块作为一个独立的仓库，也需要进行初始化
**** 克隆仓库的同时，初始化子模块
#+begin_src sh
git clone --recurse-submodules
#+end_src
**** 克隆仓库后，初始化子模块
#+begin_src sh
git submodule init
git submodule update
#+end_src
#+begin_src sh
git submodule update --init
#+end_src
*** update
+ 子模块的相关操作需要在其目录下执行
**** fetch and merge
#+begin_src sh
git submodule update --remote
#+end_src

* Org-Mode
** misc
*** tags
expense, self, work, math, cs
*** 新建一个标题行，可以在一个空行上输入一个星号，随后不要输入标题的内容，而是使用tab键切换标题行深度
*** 在tag前面输入<return>并不会导致标签内容也同样换行

** general
*** Ctrl-C Ctrl-C
+ tag :: 在headline上执行可以修改tag
+ timestamp :: normalize timestamp, fixing format
*** help
+ "C-c C-x I" :: open a suitable section of the Org manual depending on the syntax at point

** agenda
*** basic
+ "/" :: filter by tag
+ "-" :: filter out by tag

** structure template
*** create
+ "C-c C-," :: choose and insert templates

** source code block
*** edit
+ "C-c '" :: edit code block in a editing window, or return
+ "C-x C-s" :: save the block to base buffer
+ "C-c C-v v" :: view src block in a editing window
*** tangle
+ "C-c C-v t" :: tangle the current file
+ "C-c C-v f" :: choose a file to tangle
*** evaluation
+ "C-c C-c", "C-c C-v e" :: evaluate the block at point
+ "C-c C-o", "C-c C-v o" :: open result in a new window
*** navigation
+ "C-c C-v C-p", "C-c C-v C-n" :: previous/next src block
+ "C-c C-v C-u" :: goto src block head
*** help
+ "C-c C-v C-h" :: describe key bindings
+ "C-c C-v C-I" :: view src block info
+ "C-c C-v C-a" :: get SHA1 value
** speed command
point must be at the beginning of a headline
*** outline navigation
+ "n, p, f, b" :: "C-c C-"
+ "j" :: "C-c C-"
*** outline cycle
+ "c, C" :: "<tab>", "<backtab>"
*** todo
+ "t" ::
*** help
+ "?" :: describe key bindings

* Haskell
** concept
*** functor
具有类型变量的type constructor仅描述了函子中关于对象的映射关系。
只有当其成为Functor的实例后，才能真正成为了一个函子。
#+begin_src haskell
data Type a = Type a

instance Functor Type where
  fmap :: (a -> b) -> Type a -> Type b
  fmap f (Type x) = Type $ f x
#+end_src
**** example
***** Const
#+begin_src haskell
data Const a b = Const { getConst :: a }

instance Functor (Const a) where
  fmap _ (Const x) = Const x
#+end_src
***** Container
#+begin_src haskell
instance Functor [] where
  fmap :: (a -> b) -> [a] -> [b]
  fmap _ []     = []
  fmap f (x:xs) = f x : fmap f xs
#+end_src
*** natural transformation
形如以下形式的函数都可被认为是自然变换
#+begin_src haskell
naturalTransform :: (Functor f, Functor g) => f a -> g a
#+end_src
**** 以下是一些基本的实例
#+begin_src haskell
head :: [a] -> (Maybe a)
head []     = Nothing
head (x:xs) = Just x
#+end_src
**** 除此之外，还有一种比较隐式的自然变换
#+begin_src haskell
length :: [a] -> Int
length []     = 0
length (x:xs) = 1 + length xs
#+end_src
其可被等价地转换为以下形式
#+begin_src haskell
length :: [a] -> Const Int a
length []     = Const 0
length (x:xs) = Const $ 1 + getConst (length xs)
#+end_src
*** Monad

** functional
*** implementation
***** Partiality: computations that may not terminate
+ 使用一个bottom值来代表函数永不停机，由于结合了lazy evaluation机制，
 除非真正地使用到了不停机函数的返回值，否则就以bottom值作为该函数的返回值，进而使得整个程序可以继续执行。
+ 事实上，相比于Set范畴而言，虽然Hask中的每个类型都增加了一个bottom值作为成员，但Hask本身仍构成了一个范畴。
***** Nondeterminism: computations that may return many results
+ 若一个函数需要返回非固定数量的值时，通常会使用容器作为其返回值的类型。
***** Side effects: computations that access/modify state
****** Read-only state, i.e. environment
****** Write-only state, i.e. logging
****** Read/write state
***** Exceptions: partial functions that may fail
***** Continuations: ability to save state of the program and then restore it on demand
***** Interactive Input
***** Interactive Output

* Compilation
** *static library* vs. *dynamic library*
*** static linking
+ 链接库集成于可执行文件中，导致可执行文件独立但较大
 但如果一个链接库代码量过小，则将其作为动态链接库反而可能浪费内存。
 因为系统对于每个链接库元信息的维护，以及将其加载后进行的内存对齐操作，就可能导致"得不偿失"。
+ 在每次编译后都需要对链接库进行重新链接
*** dynamic linking
+ 需要系统级支持
 通常在编译器生成可执行文件时，就会向系统注册相应的链接库信息。
 当运行可执行文件时，系统的进程管理模块，会首先将所需链接库加载至内存中，随后才会加载该可执行文件。
*** runtime loading
由可执行文件主动调用dlopen()函数，以动态地触发对应链接库的加载

* Emacs
** install
*** 注意事项
+ 目前发现，Emacs安装包解压缩后不能放置于VMware的共享目录下，在make阶段会存在权限问题而报错。
*** install essential build tools
#+begin_src sh
sudo apt install build-essential
sudo apt build-dep emacs
sudo apt install libx11-dev libgtk-3-dev
sudo apt install libgnutls28-dev libncurses5-dev
sudo apt install libxpm-dev libjpeg-dev libpng-dev libgif-dev libtiff-dev  # pictures
sudo apt install libmagickcore-dev libmagick++-dev  # magick
sudo apt install libwebkit2gtk-4.0-dev  # xwidgets
#+end_src
*** install emacs
#+begin_src sh
./configure --disable-largefile --without-sound --with-modules --with-xwidgets
make
sudo make install
#+end_src
*** enable personal configurations
#+begin_src sh
cd ~/Projects
git clone http://github.com/wangtonylyan/Emacs.git
ln -s ~/Projects/Emacs ~/.emacs.d
#+end_src
*** install fonts
**** [[https://github.com/domtronn/all-the-icons.el][all the icons]]
**** [[https://github.com/adobe-fonts/source-code-pro/][source code pro]]
 #+begin_src sh
cd ~/Projects
git clone --branch release --depth 1 https://github.com/adobe-fonts/source-code-pro.git
ln -s ~/Projects/source-code-pro ~/.local/share/fonts/source-code-pro
cd ~/.local/share/fonts  # 该文件夹下的子目录也是有效的，字体文件未必一定要直接位于该目录下
sudo fc-cache -f -v
 #+end_src
**** https://github.com/wangtonylyan/Fonts, for FiraMono
*** install plugins
启动Emacs在线安装插件

* QNX
** concept
+ QNX Neutrino RTOS :: 操作系统，也被称为target system。
+ QNX Software Development Platform (SDP) :: 提供了一套交叉开发和编译环境，编译后的软件将最终部署至target system上执行。
     其部署的主机被称为development host。
+ QNX Momentics Tool Suite :: QNX Momentics IDE，包括于SDP中。
** install
*** 安装所需系统库
#+begin_src sh
sudo dpkg --add-architecture i386
sudo apt update
sudo apt install libgtk2.0-0:i386
sudo apt install libxtst6:i386 libxtst-dev:i386
sudo apt install libcanberra-gtk-module:i386
sudo apt install gtk2-engines-murrine:i386
sudo apt install libdbus-glib-1-2:i386
#+end_src
*** 安装后还需要运行以下脚本设置环境变量
#+begin_src sh
# echo >> ~/.profile
if [ -f "$HOME/qnx660/qnx660-env.sh" ]; then
    . "$HOME/qnx660/qnx660-env.sh"
fi
#+end_src
*** 执行以下命令验证安装
#+begin_src sh
qconfig
#+end_src
